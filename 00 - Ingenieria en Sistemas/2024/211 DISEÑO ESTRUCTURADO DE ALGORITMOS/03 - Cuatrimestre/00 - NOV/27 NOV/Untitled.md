---
date: 2024-11-28T01:00
tags:
  - Tarea
  - Universidad
  - Thursday
cssclasses:
  - tarea
  - Thursday
  - center-titles
  - center-images
author: youname
institution: Universidad TUP
course: Nombre del Curso
professor: Nombre del Profesor
---

# Portada
![[/99 - Meta/attachments/img/Pasted image 20240923160919.png]]

### [211 DISE√ëO ESTRUCTURADO DE ALGORITMOS 25-1](https://moodle.tecplayacar.edu.mx/course/view.php?id=6029 "211 DISE√ëO ESTRUCTURADO DE ALGORITMOS 25-1")
#### [PROF.-DANIEL GUILLERMO CONRADO MOGUEL](https://moodle.tecplayacar.edu.mx/user/view.php?id=10360&course=6029)
![[/99 - Meta/attachments/img/Pasted image 20241001021632.png]]




## **Datos del Estudiante**

- **Nombre**: Jesus Uriel Santana Oliva
- Grado : 1 -B
- **Instituci√≥n**: Tec Playacar
- Fecha: _Thursday, November 28th, 2024_
- Ubicacion : Playa del Carmen
- 
###### **Actividad
- [x] Revisi√≥n de formato APA. ‚úÖ 2024-11-28
- [x] Finalizar la bibliograf√≠a. ‚úÖ 2024-11-28
- [x] Verificar coherencia en la argumentaci√≥n. ‚úÖ 2024-11-28
- [x] Insertar gr√°ficos relevantes. ‚úÖ 2024-11-28

> [!success] Terminada
> Tarea Terminada
> 
<br>
# üîç Investigaci√≥n sobre üìö Estructuras Algor√≠tmicas y su Aplicaci√≥n

## ‚ú® Introducci√≥n
Las estructuras algor√≠tmicas son el üèóÔ∏è cimiento de la üíª programaci√≥n y el üõ†Ô∏è dise√±o de soluciones. Estas üìê estructuras definen c√≥mo se organiza un üìä algoritmo para resolver un üß© problema de manera eficiente y efectiva. La elecci√≥n de una estructura algor√≠tmica adecuada puede ser crucial para optimizar recursos como ‚è≥ tiempo y üíæ memoria.

---

# üóÇÔ∏è Clasificaci√≥n de las Estructuras Algor√≠tmicas

## 1Ô∏è‚É£ Estructuras Secuenciales
Las estructuras secuenciales representan el flujo üîÑ lineal de ejecuci√≥n, donde las instrucciones se procesan en el orden en que se presentan.

#### üåü Caracter√≠sticas:
- ‚úÖ Simples y f√°ciles de implementar.
- üõ†Ô∏è Ideales para problemas sin decisiones o iteraciones.

#### üñ•Ô∏è Ejemplo:
```python
arreglo = [1, 2, 3, 4, 5]
suma = 0
for elemento in arreglo:
    suma += elemento
print(suma)
```

Estructura Secuenciales Aplicado:‚úÖ 
![[../../../../../../ED-202411280023.excalidraw.png]]
Tenemos dos entradas num1 y num2, dos operaciones: calcular la suma y el producto de los valores ingresados y dos salidas, que son los resultados de la suma y el producto de los valores ingresados. En el s√≠mbolo de impresi√≥n podemos indicar una o m√°s salidas, eso queda a criterio del programador, lo mismo para indicar las entradas por teclado.

```java
program Proyecto4;

{$APPTYPE CONSOLE}

var
  num1, num2: Integer;
  suma, producto: Integer;

begin
  Write('Ingrese el primer valor:');
  ReadLn(num1);
  Write('Ingrese el segundo valor:');
  ReadLn(num2);
  suma := num1 + num2;
  producto := num1 * num2;
  WriteLn('La suma de los dos valores ingresados es:', suma);
  Writeln('El producto de los dos valores ingresados es:', producto);
  ReadLn;
end.

```
Previo al bloque begin end debemos definir todas las variables que hemos definido en nuestro diagrama de flujo. Podemos definir cada variable en una l√≠nea o agruparlas como hemos hecho en este problema para que se lea mejor el programa:

```java
var
  num1, num2: Integer;
  suma, producto: Integer;
```
Dentro del bloque begin end es donde disponemos nuestro algoritmo.

Mostramos un mensaje por pantalla indicando al operador que cargue el primer valor empleando el procedimiento Write:
```java
  Write('Ingrese el primer valor:');
```
Para la entrada de datos por teclado utilizamos el procedimento ReadLn donde obligatoriamente indicamos el nombre de la variable a cargar :
```java
  ReadLn(num1);
```
Los mismos pasos efectuamos para la carga del segundo n√∫mero:
```java
  Write('Ingrese el segundo valor:');
  ReadLn(num2);
```
Las operaciones las codificamos en forma id√©ntica a como lo indicamos en el diagrama de flujo. Recordar que siempre una operaci√≥n debe tener el operador de asignaci√≥n ":="
```java
  suma := num1 + num2;
  producto := num1 * num2;
```
Podemos utilizar el procedimento Write y WriteLn para mostrar mensajes y contenidos de variables simplemente separando cada una por una coma:
```java
  WriteLn('La suma de los dos valores ingresados es:', suma);
  Writeln('El producto de los dos valores ingresados es:', producto);
```
La diferencia entre Write y WriteLn es que este √∫ltimo luego de imprimir deja el cursor en la siguiente l√≠nea, es decir hace un salto de l√≠nea.

Siempre al final del programa llamamos al procedimiento ReadLn para que el operador presione una tecla y finalice reci√©n el programa:
```java
  ReadLn;
```



---

## 2Ô∏è‚É£ Estructuras de Selecci√≥n
Estas estructuras permiten tomar decisiones en base a condiciones, usando üßÆ `if-else` o `switch-case`.

#### üåü Caracter√≠sticas:
- üîÄ Permiten el control del flujo del programa.
- üîé Fundamentales para evaluar varias condiciones.

#### üñ•Ô∏è Ejemplo:
```python
numero = int(input("Ingrese un n√∫mero: "))
if numero > 0:
    print("El n√∫mero es positivo.")
elif numero < 0:
    print("El n√∫mero es negativo.")
else:
    print("El n√∫mero es cero.")
```

Construya un diagrama de flujo tal que dado como dato la cantidad de art√≠culos a comprar, escriba ‚ÄúIr a Caja R√°pida‚Äù en caso de que este n√∫mero sea menor a 8 art√≠culos.

Datos de entrada:
1. Cantidad de art√≠culos a comprar.
2. (Definici√≥n de variable) CantA:
3. Variable de tipo real que representa la cantidad de art√≠culos a comprar.
4. Resultado esperado o datos de salida:
5. El enunciado ‚ÄúIr a Caja R√°pida‚Äù en caso de que el n√∫mero de art√≠culos a comprar sea menor a 8.
6. (Definici√≥n de variable)
7. No se requieren variables se imprimir√° una cadena de caracteres.


**Proceso:**
*(Algoritmo)*
1. Inicio
2. Leer la cantidad de art√≠culos a comprar. CantA.
3. Evaluar si la cantidad de art√≠culos a comprar es menor a 8.
	1. Si la cantidad de art√≠culos a comprar es menor a 8, imprimir ‚ÄúIr a la Caja R√°pida‚Äù.
4. Fin



![[../../../../../../99 - Meta/attachments/img/Pasted image 20241128010417.png]]

```c
Inicio
¬†¬†¬†¬† Leer CantA
¬†¬†¬†¬† Si CantA<8 entonces
¬†¬†¬†¬†¬†¬†¬†¬†¬† Imprimir ‚ÄúIr a Caja R√°pida‚Äù
¬†¬†¬†¬† Fin Si

Fin
```
En la siguiente tabla observamos el seguimiento del diagrama de flujo para diferentes corridas. Cabe aclarar que una corrida es una ejecuci√≥n del programa.


![[../../../../../../99 - Meta/attachments/img/Pasted image 20241128010457.png]]

---

## 3Ô∏è‚É£ Estructuras Repetitivas (Bucles)
Permiten ejecutar un bloque de c√≥digo varias veces, ya sea con `for` o `while`.

**Estructuras Repetitivas (Bucles)**

Un bucle o lazo (Loop)¬† es un segmento de un algoritmo o programa, cuya instrucciones se repiten un n√∫mero determinado de veces mientras se cumple una determinada condici√≥n (existe o es verdadera la condici√≥n). SE debe establecer un mecanismo para determinar las tareas repetitivas. Este mecanismo es una condici√≥n que puede ser verdadera o falsa y que se comprueba una vez a cada paso o iteraci√≥n del bucle (total de instrucciones que se repiten en el bucle).

Un bucle consta de tres partes:

+  Decisi√≥n,
- ¬†cuerpo del bucle,
- ¬†salida del bucle.
    

El bucle de la¬†siguiente¬†figura¬† es infinito, ya que las instrucciones (1), (2) y (3) se ejecutan indefinidamente, pues no existe salida del bucle, al no cumplirse una determinada condici√≥n.

#### üåü Caracter√≠sticas:
- üîÅ √ötiles para procesamiento repetitivo.
- ‚öôÔ∏è Combinables con estructuras de selecci√≥n para m√°s flexibilidad.

#### üñ•Ô∏è Ejemplo:
```python
for i in range(1, 11):
    print(i)
```




#### OBJETIVO ESPEC√çFICO

Emplear las estructuras repetitivas para seleccionar la m√°s adecuada y aplicarlas en la soluci√≥n de problemas utilizando algoritmos espec√≠ficos.

CONTENIDO
- Ciclos iterativos
- Contadores y acumuladores
- Ciclos de la estructura tipo FOR ‚Äì NEXT ‚Äì END FOR
- Ciclos de la estructura tipo DO ‚Äì UNTIL
- Ciclos de la estructura tipo WHILE ‚Äì END WHILE


![[../../../../../../99 - Meta/attachments/img/Pasted image 20241128011742.png]]

Si tras la lectura de la variable N se coloca una condici√≥n, el bucle dejar√° de ser infinito y tendr√° fin cuando la condici√≥n sea verdadera.

El diagrama de flujo escrito en pseudo c√≥digo es¬†aproximadamente el siguiente:
```
Inicio
¬†¬†¬†¬†SUMA 0
¬†¬†¬†¬†1: leer N
¬†¬†¬†¬†Si N = 0 entonces
¬†¬†¬†¬†¬†¬†¬†¬†Escribir SUMA
¬†¬†¬†¬†¬†¬†¬†¬†Ir_a fin
¬†¬†¬†¬†Si_no
¬†¬†¬†¬†¬†¬†¬†¬†Suma suma + N
¬†¬†¬†¬†FIN_SI
¬†¬†¬†¬†IR_A 1
FIN

```
  
![](https://enriquebarrueto0.tripod.com/algoritmos/bucle2.gif)

**BUCLES ANIDADOS**

Un bucle puede anidarse dentro de otro como se vio en clase con los condicionales anidados (un¬†**si**¬†**fin_si**¬†dentro de otro¬†**si Fin_si**)

**Contadores**

Un contador es una variable cuyo valor se incrementa o decremento en una cantidad constante en cada¬†vuelta.

La¬†siguiente figura¬†

![](https://enriquebarrueto0.tripod.com/algoritmos/bucle3.gif)contar del 1 al 50

presenta un diagrama de flujo para un algoritmo que se desea repetir 50 veces; el contador se representa en este ejemplo con la variable CONT. La instrucci√≥n que representa a un contador es la asignaci√≥n CONT¬†=¬†CONT + 1.

La¬†siguiente figura

![](https://enriquebarrueto0.tripod.com/algoritmos/bucle4.gif)Decrementar desde N hasta 0

es otro ejemplo de un diagrama de flujo con contador;¬†**es este caso, negativo**. Se dice tambi√©n descontar.

El contador puede ser positivo (incrementos, uno en uno) o negativo (decrementos, uno en uno).

**Importante acerca de incrementos y decrementos:**

En la¬†primera¬†Figura el contador cuenta desde 1 al 50 y deja de contar cuando la variable CONT toma el valor 51 y se termina el bucle.

En la¬†segunda¬†Figura el contador cuenta negativamente, o lo que es lo mismo, descuenta o decrementa; comienza a contar en n y se decrementando hasta llegar a cero, en cuyo caso se termina el bucle y se realiza la acci√≥n escribir.

Como se vio anteriormente la condici√≥n permite terminar el bucle cuando √©sta es verdadera (si)¬†

ahora veremos las estructuras repetitivas que se usar√°n en el curso de algoritmos:

**Tipos de estructuras repetitivas**
```python
Mientras Condicion Hacer
Fin_mientras
Desde Variable=inicio¬† Hasta Variable=Final¬† hacer
Fin_desde 
(La anterior tambi√©n puede ser usada con la palabra PARA en vez de DESDE 

 ejemplo:
¬†¬†¬† PARA Variable=inicio¬† Hasta Variable=Final¬† hacer
¬†¬†¬† Fin_PARA) 
Repetir
Hasta Condicion

```

Hemos visto que las¬†Estructura repetitivas¬†son aquellas en las que especialmente se dise√±a para todas aquellas

aplicaciones en las cuales una operaci√≥n o conjunto de ellas deben repetirse¬†muchas veces.

asi los¬†Bucles (lazos¬†o LOOPs)¬†Son estructuras que repiten una secuencia de¬†instrucciones un numero determinado de veces.

Interacci√≥n: Es el hecho de repetir la ejecuci√≥n de una secuencia de¬†acciones; en otras palabras el algoritmo repite muchas veces las acciones.

Al utilizar un bucle para sumar una lista de n√∫meros, se necesita saber¬†cuantos n√∫meros se han de sumar, para poder detenerlo en el momento preciso; las¬†dos principales preguntas ha realizarse en el dise√±o de un bucle son:

¬øQue contiene¬†el bucle? y ¬øCu√°ntas veces se debe repetir?

¬†**Casos Generales de Estructuras repetitivas**

1) La condici√≥n de Salida del bucle se realiza al principio del bucle (**estructura¬†mientras**)¬†tambi√©n llamada PRE-CONDICIONAL

2) La condici√≥n de Salida se origina al final del bucle; el bucle se verifica hasta que¬†se verifique una cierta condici√≥n

tambi√©n llamada POST-CONDICIONAL (**estructura Repetir Hasta**).

3) La condici√≥n de salida se realiza con un contador que cuente el numero de¬†interacciones. ( i es un contador que cuenta desde el valor inicial (vi.) hasta el¬†valor final (vf) con los incrementos que se consideren.)¬†(estructura DESDE o PARA)

**Estructura mientras ("while")**

Es aquella en que el cuerpo del bucle se repite mientras se cumple¬†una determinada condici√≥n.¬†Cuando se ejecuta la acci√≥n¬†¬†**mientras,**¬†la primera¬†cosa que sucede es que se eval√∫a la condici√≥n (una expresi√≥n booleana¬†que devuelve Verdadero o Falso), si se eval√∫a¬†falsa ninguna acci√≥n se tomara y el programa en la siguiente instrucci√≥n del bucle; si la¬†expresi√≥n booleana es verdadera, entonces se ejecuta el cuerpo del bucle, depuse del¬†cual se eval√∫a de nuevo la expresi√≥n booleana.

Esta expresi√≥n booleana se repite una y otra vez mientras la¬†expresi√≥n booleana (condici√≥n) sea verdadera¬†

**Estructura repetir ("repeat").**

Si el valor de la expresi√≥n booleana es inicialmente falso, el cuerpo del¬†Bucle no se ejecutara, por ello se necesitan de otros tipos de estructuras.¬†Dicha estructura se ejecuta hasta que cumpla una condici√≥n¬†determinada que se comprueba hasta el final del bucle

¬†**Diferencias entre las estructuras mientras y repetir**

- La estructura¬†**mientras**¬†termina cuando la condici√≥n es falsa, mientras que¬†**repetir**¬†termina cuando la condici√≥n es verdadera.
    
- En la estructura¬†**repetir**¬†el cuerpo del bucle se ejecuta siempre al menos una sola¬†vez; por el contrario¬†**mientras**¬†es mas general y permite la posibilidad de que el¬†bucle pueda no ser ejecutado.
    
- Para usar la estructura¬†**repetir**¬†debe estar seguro¬†de que el cuerpo del bucle se repetir√° al menos una sola vez.
    

**Estructura desde/para ("for").**

Son el numero total de veces que se desea ejecutar las acciones del¬†Bucle (numero de interacciones fijo), este ejecuta las acciones del cuerpo o del¬†Bucle un numero especifico de veces y de modo autom√°tico controla el numero de¬†Interacciones o pasos a trav√©s del cuerpo del bucle.

**Ejemplos con Mientras**

**Forma de Uso**

> > **Mientras**¬†condicion¬†**hacer**
> > 
> > ¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬† acci√≥n 1
> > 
> > ¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬† acci√≥n 2
> > 
> > ¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬† acci√≥n 3
> > 
> > ¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬† ....
> > 
> > ¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬† acci√≥n n
> > 
> > **Fin_Mientras**

1.- Hacer un programa que cuente del uno al 10
```python
Inicio
¬†¬†¬† x= 1
¬†¬†¬† Mientras x<=10 hacer
¬†¬†¬†¬†¬†¬†¬† Escribir x
¬†¬†¬†¬†¬†¬†¬† x= x + 1
¬†¬†¬† Fin_Mientras
Final
```

---

## 4Ô∏è‚É£ Dividir y Vencer (Divide and Conquer)
Esta estructura implica dividir un üß© problema en subproblemas, resolverlos de forma independiente y combinar las soluciones.
![[../../../../../../99 - Meta/attachments/img/Pasted image 20241204143613.png]]

#### üåü Caracter√≠sticas:
- ‚ö° Eficiente para problemas descompuestos recursivamente.
- üì¶ Requiere dise√±ar algoritmos que equilibren la divisi√≥n y la combinaci√≥n.

#### üñ•Ô∏è Ejemplo:
```python
def merge_sort(arr):
    if len(arr) > 1:
        mid = len(arr) // 2
        izquierda = arr[:mid]
        derecha = arr[mid:]

        merge_sort(izquierda)
        merge_sort(derecha)

        i = j = k = 0
        while i < len(izquierda) and j < len(derecha):
            if izquierda[i] < derecha[j]:
                arr[k] = izquierda[i]
                i += 1
            else:
                arr[k] = derecha[j]
                j += 1
            k += 1

        while i < len(izquierda):
            arr[k] = izquierda[i]
            i += 1
            k += 1

        while j < len(derecha):
            arr[k] = derecha[j]
            j += 1
            k += 1
```

---

## 5Ô∏è‚É£ Programaci√≥n Din√°mica
Se basa en resolver problemas dividi√©ndolos en subproblemas y reutilizar soluciones calculadas.
![[../../../../../../99 - Meta/attachments/img/Pasted image 20241204144301.png]]

#### üåü Caracter√≠sticas:
- ‚öôÔ∏è Eficiente para problemas con subproblemas superpuestos.
- üìà Com√∫n en optimizaci√≥n.

#### üñ•Ô∏è Ejemplo:
```python
fib_cache = {}
def fibonacci(n):
    if n in fib_cache:
        return fib_cache[n]
    if n <= 2:
        return 1
    fib_cache[n] = fibonacci(n-1) + fibonacci(n-2)
    return fib_cache[n]
```

---

## 6Ô∏è‚É£ Algoritmos Greedy (Avaros)



![[../../../../../../99 - Meta/attachments/img/Pasted image 20241204144448.png]]

#### üåü Caracter√≠sticas:
- üõ†Ô∏è Simples de implementar.
- ‚ùå No siempre garantizan la soluci√≥n √≥ptima.

#### üñ•Ô∏è Ejemplo:
```python
def mochila_greedy(capacidad, objetos):
    objetos.sort(key=lambda x: x[1]/x[0], reverse=True)
    peso_total = 0
    beneficio = 0
    for peso, valor in objetos:
        if peso_total + peso <= capacidad:
            peso_total += peso
            beneficio += valor
        else:
            fraccion = (capacidad - peso_total) / peso
            beneficio += valor * fraccion
            break
    return beneficio
```

---

## üìä Comparaci√≥n entre Estructuras Algor√≠tmicas

| üèóÔ∏è Estructura             | ‚úÖ Ventajas                                  | ‚ùå Desventajas                           |
|------------------------|-------------------------------------------|---------------------------------------|
| Secuenciales           | üëç Simples y directas.                      | üõë No aplicables a problemas complejos.  |
| Selecci√≥n             | üîÄ Flexibilidad en el flujo.                | üåÄ Complicadas con m√∫ltiples condiciones. |
| Repetitivas            | ‚ôªÔ∏è Procesamiento automatizado de datos.     | ‚ö†Ô∏è Riesgo de ciclos infinitos.           |
| Dividir y vencer       | ‚ö° Eficiencia en problemas recursivos.      | üíæ M√°s memoria para subproblemas.        |
| Programaci√≥n din√°mica | üõ†Ô∏è Evita redundancias.                      | üß† Complejidad en su implementaci√≥n.    |
| Greedy                 | ‚úÖ F√°cil de entender y codificar.           | ‚ùå No siempre √≥ptimo.                   |

---



