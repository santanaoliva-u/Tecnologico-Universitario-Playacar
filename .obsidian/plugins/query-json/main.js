/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => QJSON
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");

// src/functions.ts
function parseQuery(query) {
  const parts = query.split(".");
  return parts.map((part) => {
    const match = part.match(/(\w+)\[(.*)\]/);
    if (match) {
      return {
        type: "filter",
        field: match[1],
        condition: match[2]
      };
    }
    return {
      type: "field",
      name: part
    };
  });
}
function parseCondition(condition) {
  const logicalOperators = ["&&", "||"];
  let conditions = [];
  let operators = [];
  let remainingCondition = condition;
  logicalOperators.forEach((operator) => {
    if (remainingCondition.includes(operator)) {
      const parts = remainingCondition.split(operator).map((s) => s.trim());
      conditions.push(parseSingleCondition(parts[0]));
      operators.push(operator);
      remainingCondition = parts[1];
    }
  });
  if (conditions.length === 0) {
    conditions.push(parseSingleCondition(remainingCondition));
  } else {
    conditions.push(parseSingleCondition(remainingCondition));
  }
  return { conditions, operators };
}
function parseSingleCondition(condition) {
  const comparisonOperators = [">=", "<=", "==", ">", "<", "!=", "*"];
  for (let operator of comparisonOperators) {
    if (condition.includes(operator)) {
      const [key, value] = condition.split(operator).map((s) => s.trim());
      return { key, operator, value };
    }
  }
  throw new Error(`Invalid condition: ${condition}`);
}
function executeQuery(json, parsedQuery) {
  let result = json;
  let finalResult;
  parsedQuery.forEach((part) => {
    if (part.type === "field") {
      result = result[part.name];
    } else if (part.type === "filter") {
      const { conditions, operators } = parseCondition(part.condition);
      const filteredResult = result[part.field].filter((item) => {
        return evaluateConditions(item, conditions, operators);
      });
      if (!finalResult) {
        finalResult = filteredResult;
      } else {
        finalResult = finalResult.concat(filteredResult);
      }
    }
  });
  finalResult = finalResult || result;
  try {
    if (parsedQuery.length > 0 && parsedQuery[parsedQuery.length - 1].type === "field") {
      finalResult = finalResult.map((item) => item[parsedQuery[parsedQuery.length - 1].name]);
    }
  } catch (e) {
    console.error(e);
    return finalResult;
  }
  return finalResult;
}
function evaluateConditions(item, conditions, operators) {
  let result = evaluateCondition(item, conditions[0]);
  for (let i = 0; i < operators.length; i++) {
    const operator = operators[i];
    const nextConditionResult = evaluateCondition(item, conditions[i + 1]);
    if (operator === "&&") {
      result = result && nextConditionResult;
    } else if (operator === "||") {
      result = result || nextConditionResult;
    }
  }
  return result;
}
function evaluateCondition(item, condition) {
  const { key, operator, value } = condition;
  switch (operator) {
    case "*":
      return true;
    case ">=":
      return item[key] >= Number(value);
    case "<=":
      return item[key] <= Number(value);
    case "==":
      return item[key] == value;
    case ">":
      return item[key] > Number(value);
    case "<":
      return item[key] < Number(value);
    case "!=":
      return item[key] != value;
    default:
      return false;
  }
}

// src/main.ts
var QJSON = class extends import_obsidian.Plugin {
  async onload() {
    const statusBarItemEl = this.addStatusBarItem();
    let qjCount;
    function updateStatusBarCounter() {
      qjCount = document.querySelectorAll(".cdQjson").length;
      statusBarItemEl.setText("QJSON: " + qjCount);
    }
    this.registerEvent(this.app.workspace.on("file-open", () => {
      updateStatusBarCounter();
    }));
    this.registerMarkdownCodeBlockProcessor("qjson", async (source, el) => {
      if (!source.includes("#qj-id:")) {
        new import_obsidian.Notice("No ID found");
        el.createEl("pre", { text: "No ID found" });
        return;
      }
      let id;
      id = source.match(/#qj-id: (\d+)/);
      if (id)
        id = id[1];
      if (isNaN(parseInt(id))) {
        new import_obsidian.Notice("ID must be a number");
        el.createEl("pre", { text: "ID must be a number" });
        return;
      }
      let query;
      if (source.includes("#qj-query:")) {
        query = source.match(/#qj-query: (.+)/);
        if (query) {
          query = query[1];
        } else {
          new import_obsidian.Notice("No query found");
          el.createEl("pre", { text: "No query found" });
          return;
        }
        query = parseQuery(query);
      }
      let format;
      if (source.includes("#qj-format:")) {
        format = source.match(/#qj-format: (.+)/);
        if (format) {
          format = format[1];
        } else {
          new import_obsidian.Notice("No format found");
          el.createEl("pre", { text: "No format found" });
          return;
        }
      }
      let desc;
      if (!source.includes("#qj-hide-id")) {
        try {
          desc = source.match(/#qj-desc: (.+)/);
          if (desc)
            desc = desc[1];
        } catch (e) {
          desc = "\xBB\xBB\xBB QJSON \xAB\xAB\xAB";
        }
        el.createEl("h3", { text: desc, cls: "centerQJtext" });
        el.createEl("h4", { text: "ID: " + id, cls: "centerQJtext" });
      }
      let showJson = "notHere";
      if (source.includes("#qj-show-json")) {
        showJson = "";
      }
      if (source.includes("#qj-file:")) {
        const file = source.match(/#qj-file: (.+)/);
        if (file) {
          source = await this.app.vault.adapter.read(file[1]);
        } else {
          new import_obsidian.Notice("No file found");
          el.createEl("pre", { text: "No file found" });
          return;
        }
      }
      const json = JSON.parse(source);
      if (query) {
        const result = executeQuery(json, query);
        if (format && query[query.length - 1].type === "field") {
          if (format === "list") {
            const ul = el.createEl("ul");
            if (typeof result === "string") {
              ul.createEl("li", { text: result });
            } else {
              for (let i = 0; i < result.length; i++) {
                ul.createEl("li", { text: JSON.stringify(result[i], null, 2) });
              }
            }
          } else if (format === "table") {
            const table = el.createEl("table");
            const tbody = table.createEl("tbody");
            if (typeof result === "object") {
              for (const key in result) {
                const tr = tbody.createEl("tr");
                tr.createEl("th", { text: key });
                tr.createEl("td", { text: JSON.stringify(result[key], null, 2) });
              }
            } else {
              const tr = tbody.createEl("tr");
              tr.createEl("td", { text: result });
            }
          } else if (format === "img") {
            if (typeof result === "string") {
              el.createEl("img", { attr: { src: result } });
            } else {
              for (let i = 0; i < result.length; i++) {
                el.createEl("img", { attr: { src: result[i], width: 100, height: 100 } });
              }
            }
          }
          return;
        }
        el.createEl("pre", { text: JSON.stringify(result, null, 2), cls: "QJSON-" + id + " cdQjson " + showJson });
      } else {
        el.createEl("pre", { text: JSON.stringify(json, null, 2), cls: "QJSON-" + id + " cdQjson " + showJson });
      }
      updateStatusBarCounter();
    });
    this.registerEvent(this.app.workspace.on("editor-change", async (editor) => {
      const cursor = editor.getCursor();
      const line = editor.getLine(cursor.line);
      const lastChar = line[line.length - 1];
      const match = line.match(/@(.+)>(.+)|@(.+)>/);
      if (!match)
        return;
      if (lastChar !== ";" && lastChar !== "." && lastChar !== ">" && lastChar !== "]")
        return;
      const id = match[1] || match[3];
      let path = "";
      if (match[2] !== void 0) {
        path = match[2].slice(0, -1).replace(/>/, "");
      }
      let json;
      if (!isNaN(parseInt(id)) && !id.includes(".json")) {
        const el = document.querySelector(".QJSON-" + id);
        if (!el)
          return;
        json = JSON.parse(el.textContent || "");
      } else {
        json = JSON.parse(await this.app.vault.adapter.read(id));
      }
      path = path.replace(/\*/g, "").replace(/\[\]/g, "");
      let value = getJSONPath(json, path);
      if (lastChar !== ";") {
        if (value !== void 0) {
          const notice = document.querySelector(".notice");
          if (notice)
            notice.remove();
          const keys = Object.keys(value);
          const keysAreNumbers = keys.every((key) => !isNaN(parseInt(key)));
          if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
            new import_obsidian.Notice(value.toString());
          } else if (keysAreNumbers) {
            new import_obsidian.Notice("Total Keys: " + (keys.length - 1));
          } else {
            new import_obsidian.Notice("Total Keys: " + keys.length + "\n____________\n" + keys.join("\n"));
          }
        }
      } else {
        if (line.includes("[*]")) {
          const temp_data = [];
          const arrayMatch = line.match(/(.+)\[\*\](?:\.(\w+))?/);
          if (arrayMatch) {
            const arrayKey = arrayMatch[1].slice(arrayMatch[1].indexOf(">") + 1);
            const property = arrayMatch[2];
            const arrayElements = getJSONPath(json, arrayKey);
            for (let i = 0; i < arrayElements.length; i++) {
              if (property) {
                temp_data.push(arrayElements[i][property]);
              } else {
                temp_data.push(arrayElements[i]);
              }
            }
          }
          value = temp_data;
        }
        const atIndex = line.indexOf("@");
        const replaceEnd = { line: cursor.line, ch: line.length };
        const stringValue = typeof value === "string" ? value : JSON.stringify(value);
        editor.replaceRange(stringValue, { line: cursor.line, ch: atIndex }, replaceEnd);
      }
    }));
  }
};
function getJSONPath(json, path) {
  if (path === "")
    return json;
  return path.split(".").reduce((acc, key) => acc[key], json);
}


/* nosourcemap */